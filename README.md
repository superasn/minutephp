##MinutePHP: PHP + AngularJS framework (*v.001*)##

###Framework's USP:###

- Built-in support for AngularJS
- Router can automatically inject `Model` objects into controller (which can be accessed via AngularJS too)
- CRUD operations can be done with one single line of code in both PHP and AngularJS

###Project status###
It's highly experimental code! I just want to share the concept (and code) to see **if anyone interested in collaborating** :)

###**Demo: Facebook like newsfeed** 

**Demo:** Create a facebook like newsfeed in 2 minutes (using minimum code).

**Database setup:** Our MySQL database contains a `user` table (`PK: user_id`), `posts` table (`PK: post_id`) and `comments` table (`PK: comment_id`). 

The `posts` table references the `users` table (since the users make posts) and `comments` table references both `users` and `posts` table (because comments are made on posts by users).

**Understanding the _new_ Router syntax:**

```php 
$r->get($url, $controller, $acl, â€¦$models)
```

The first three arguments are pretty standard:

1. *$url:* URL *regex* to match address bar. Can contain placeholders (or regex). Placeholder format is ":name"
  -1. Examples:
     1. /newsfeed/:user\_id/
     2. /newsfeed/:user\_id(/:page)? *[here page parameter is optional]*

2. *$controller:* format is similar to Laravel like "Filename@function"
  - Examples:
     1. Backend/Newsfeed@index *[This will invoke the `index` function in `Backend/Newsfeed` class]*

3. *$acl:* can be "true" for logged in otherwise false. 
	- Also supports strings like 'admin', 'power', 'business', 'trial', 'etc' (as defined in config file)
	
4. **...$model objects: This is the unique part.**
  1. What are model objects?
     1. Models are basically PHP objects that support CRUD operations (in both PHP and AngularJS). Something similar to an ORM but not that (as explained later).
     2. The model classes are *automatically* generated by a script. So for our sample database MinutePHP has generated 5 PHP Model classes called *Users, Posts, Comments, PostsLikes and CommentsLikes*
     3. You can specify the Read, Update, Insert, and Delete permission for each model as "same\_user", "any\_user", "all", "none", "admin", etc (more later).

5. **The Router automatically injects these Model objects when invoking the Controller**

**Here is some sample code:**

**File: `index.php`**
```php
//$r is instance of Router
//Sample matching routes are /newsfeed/1, /newsfeed/2, .. (last part => :user_id)
$r->get('/newsfeed/:user_id', 'Backend/Newsfeed@index', true, 'posts[user_id][]', 'users[posts.user_id] as poster')
```
Explanation of the *last two parameters*:
   
1. ***posts[user_id][]*** - will find all rows in `posts` table with `user_id` = `:user_id` (the placeholder in URL). What this means to you is:
   1.  It will then create `$posts` object (instance of Posts model) with an array of matching rows loaded from our `posts` table where `user_id=1` (if URL is */newsfeed/1*).
   2.  It will pass the `$posts` object when invoking the controller (shown below). 
   3. It will **create an AngularJS object** for `$posts`, **accessible as `$scope.posts` inside the view**.
   4. The **[ ]** at end is to specify we want *all* matching results (i.e. an array).
   5. By default all models have a read permission of *same\_user*, so /newsfeed/2 will return *permission denied error* (if the logged in user's `user_id` is **1** and you try to access /newsfeed/**2**).
   
	- Example: /newsfeed/**1** will create a `$posts` object and fill it with rows where user_id=**1**.
	
2.  ***users[posts.user_id] as poster*** - this will create a join on `posts` and `users` table using `user_id`. As a result you will have:
   1. A `$poster` object (instance of User model) in your controller. 
   2. A reference to the `poster` inside each row of `$posts` object.
   3. If it is getting confusing, think of it like an SQL query:
```SELECT * FROM posts as A, users as b where user_id = :user_id and b.user_id = a.user_id```
   4. It will also **create an AngularJS object** for you that you can **access as `$scope.posts[0].poster`, `$scope.posts[1].poster.firstName`**, etc in your view.
  5. Note that **there is no [] at the end** this time. It means that we want to load just our **first matching row** (returns single object not array. In JSON speak, it returns `{}` and not `[{}, {}, ...]`)

**Controller:** `Backend/Newsfeed class`
```php
//This is the Controller class. It is invoked by the Router when a person accesses /newsfeed/1, /newsfeed/2, etc in browser. 

public function index($posts, $poster) {
	//$posts and $poster are automatically filled for us

    //Render Backend/Newsfeed view located in Views folder 
    //Magically create an AngularJS object for $posts

	View::make('Backend/Newsfeed', $posts); 
}
```
**View:** `Views/Backend/Newsfeed.html`
```html
<div class="container">
	Hello!
	
	<ng-form>Add new post: <input type="text" ng-model="newtitle" /><button ng-click="createPost();">Create post</button></ng-form>
		
	<h3>Existing posts</h3>

	<!-- Remember $scope.posts is now an AngularJS object! -->
	<div ng-repeat="post in posts">
		<h3>{{post.title}}</h3> by post.poster.first
		
		<ng-form><input type="text" ng-model="mytitle" value="changed title" />
		   <button ng-click="updatePost(post);">Update post</button><ng-form>
	</div>
</div>

<script>
function extend($scope) {
	$scope.createPost = function() {
	    //will create a new post and with the user's title
		var post = $scope.posts.create().set('title', $scope.newtitle).save();
		console.log("post: ", post); //will have post_id, etc
	}
		
	$scope.updatePost = function(item) {
		//will change the post's title to user input
		item.set('title', $scope.mytitle).save();
	}
}
</script>
```

###So are you with me so far? :)###

As you can see above, the View class automatically converted our $posts Model into an AngularJS object and added it to our current `$scope` as `$scope.posts`

`$scope.posts` is an _array of objects_ on which you can iterate with ng-repeat.

`$scope.posts` is an array but it has a few functions of its own like `.create()`, `loadNextPage()`, etc. 

Each item in `$scope.posts` array is an object of `Record` type (let's call it a `PostItem` in this case) with functions like `set()`, `save()`, etc.

**But here is the most interesting part!**

Do you remember about our `users[posts.user_id] as poster` in the router? 

What this means to you is that we first created a `$posts` array. Then we created `$poster` object (instance of Users Model) and joined it with the users table by matching the `user_id`.

So what this also means to you is that each item inside `$scope.posts` there is a reference to it's `poster` object as well.

So `{{$posts[0].poster.firstName}}` will print the first name of the poster in AngularJS.

>Too hard to comprehend? I hope not! :) But I'll give you another example..

Also let's add two more tables called `posts_likes` and `comments_likes`.  
	- `posts_likes` contains two fields called `user_id` and `post_id` to keep track of which `user` liked which `post`. 
	- `comments_likes` similary contains two fields called `user_id` and `comment_id` to keep track of which `user` liked which `comment`. 

Ok, now take a look at this route.. you'll probably go *whaaaaa*, but the concept behind it is simple and once you get it, things will begin to look very easy! :)

```php
$r->get('/newsfeed/:user_id', 'Backend/Newsfeed@index', false,

    'posts[user_id][2] order by post_id asc', 'users[posts.user_id] as poster',

    'postsLikes[posts.post_id][] as plikes', 'users[plikes.user_id] as pliker',

    'comments[posts.post_id][] order by comment_id desc', 'users[comments.user_id] as commenter',

    'commentsLikes[comments.comment_id][] as clikes', 'users[clikes.user_id] as cliker'
);
```

Now let's pull every single parameters apart to make things clear:

1. `posts[user_id][2] order by post_id asc` Same as last example, only difference is
   1. We load only the first two records only, hence the [2] instead just [] at the end. 
   2. To load more records we can call `$scope.posts.loadNextPage()` inside AngularJS.
   3. You can also use `posts[user_id][1,5]` syntax.
	   - Here the first digit is page number, second digit is number of results. 
	   - So this will load the second page (page starts at 0) with 5 results, i.e. rows: 5 ~ 10.
2.  `users[posts.user_id] as poster` Same as last time. We want to load the poster of each post by creating a join on posts.user_id on the users table. Remember that since we don't have a trailing [] at the end, it tells MinutePHP we want the first matching object (not the whole array of matching results).
3. `postsLikes[posts.post_id][] as plikes` Create a `$postsLikes` object by creating a join on `posts`  and `post_likes` table using `post_id`.
4. `users[plikes.user_id] as pliker` We want to know the name of user who liked the post. So we create a `$pliker` object creating a join on `users` and `postsLikes` (alias plikes) table using `user_id`.
5. `comments[posts.post_id][] order by comment_id desc` Since each posts can have comments inside it, we create a `$comments` object joining `posts` and `comments` using `post_id`.
   6. Since we wish to load the comments in the reverse order in which they were posted, we add an order by clause: `order by comment_id desc` (same as SQL).
6. `users[comments.user_id] as commenter` We also want the name of the user who made the comment, so we create a new `$commenter` object joining the `comments` and `users` table using `user_id`.
7. `commentsLikes[comments.comment_id][] as clikes` This is pretty much same as postLikes, except we're using it for commentsLikes.

	-*Note:* that some Models end with `[]` while other don't. In case you've forgotten that is because some times we want the whole array of objects, as in case of $posts, $comments, etc. But other times we just want the first object, as in the user who made the post, or user who made the comment, etc.

When we render our view all these objects will be converted to AngularJS objects. So broadly speaking our code will look something like this:

```html
<div ng-repeat="post in posts">
	{{post.title}} by {{post.poster.first}}

	<div ng-repeat="comment in post.comments">
		{{comment.title}} by {{comment.commenter.first}}		
	</div>

	<input type="text" ng-model="userinput" />
	<button ng-click="createItem(post.comments)">Add comment</button>
</div>

<input type="text" ng-model="userinput" />
<button ng-click="createItem(posts)">Add new post</button>

<button ng-click="posts.loadNextPage();" ng-show="posts.$more">Next page ></button>
```

What it does?
- Show the first two posts, print their titles along with the name of the user who made the post.
- Inside each post will be all the comments with the name of the user who made it!
- A logged in user can add a new post to this page.
- A logged in user can add a new comment under each post.
- The Next page button will add two more posts.

Similar to example #1, if you want the user to create a new post or comment, all you have to do is this:

```html
<script>
function extend($scope) {
	$scope.createItem = function(item) {
	    //will create a new post or comment
		item.create().set('title', $scope.userinput).save();
	}
}
</script>
```

Now the last part. How to add comment and post likes? Well, it's easy.

We already have created a `$plikes` object for each post. Let's say we want to show the number of people who like the post:

```html
<div ng-repeat="post in posts">
	{{post.title}} by {{post.poster.first}}

	<span>{{post.plikes.count-1}} like this post!</span>
	<ng-switch on="didILike(post.plikes)">
		<a ng-show-when="false" ng-click="likePost(post)">like this post!</a>
		<a ng-show-default ng-click="unLikePost(didILike(post.plikes))">Unlike!</a>
	</ng-switch>
</div>

<script>
function extend($scope) {
	$scope.likePost = function(post) {
	    post.plikes.create().save();
	}
	
	$scope.unLikePost = function(plike) {
	    plike.remove();
	}

	$scope.didILike = function(arr) {
		//using underscore.js, return object where user_id == 1;
		return _.findWhere(arr, { user_id: 1}) || false;
	}
}
</script>	
```

To quickly explain the above code:

When a user likes a post we simply have to add the user\_id, and post\_id to our `PostsLikes` table. So in our case we just call `plikes.create()` and save it.

The `didILike` function is basically returns the first matching object inside the `$scope.posts.plikes` array where the object has `user_id` = 1 (we assume the logged in user's user_id = 1 for this demo).

To unlike a post, we simply just pass this Record (or the matching item inside the `$scope.posts.plikes` array) and call the remove function on it, thus deleting the record and removing the like.

To keep things simple I have not covered the creation, updating and removal of objects so far. By default all models are created with the following permissions:
	- **Read** permission: `same_user` (i.e. the person who created the record can only read it.. or basically the user_id has to match)
	- **Update** permission: `same_user` (i.e. the person who created the record can only update it..)
	- **Insert** permission: `none` (nobody can insert anything by default)
	- **Delete** permission: `none` (nobody can delete anything by default)

So to let users insert or delete stuff we have to setup routes to make it possible. The only code you have to add here is change the Model permissions to allow this to happen.

So take this sample:

**File: `index.php`**

```php
//$r->get('/newsfeed/:user_id', 'Backend/Newsfeed@index', false, ...
  $r->post('/newsfeed/:user_id/posts/update', 'Backend/Newsfeed@updatePosts', false, 'posts[$data]');
```

**Controller:** `Backend/Newsfeed class`
```php
//This is the Controller class. It is invoked by the Router when a person makes a POST request to /newsfeed/1/posts/update

public function updatePosts($posts) {
    if ($posts->getAction() == 'remove') {
        $posts->setDeletePermission('same_user');
        $success = $posts->remove();
    } else {
        $posts->setUpdatePermission('same_user');
        $posts->setInsertPermission('same_user');
        $success = $posts->save();
    }

    View::getInstance()->make('Backend/Newsfeed', $success);
}
```

The advantage of this approach is that your scripts will continue to work even if the user has disabled Javascript on her end. This is important for Signup pages, old mobile devices, etc.

###Generating Model Classes and Controllers###

You don't have to write most of the stuff by hand. The *minute.php* `CLI` script will create both Models and Controllers Classes for you.

**Examples:**
```php
#To create Model Classes (only support MySQL currently)
$> php Minute/CLI/minute.php --create-models --db=fb --host=localhost --user=root

#To generate Controller classes (file must be inside `public` directory)
$> php Minute/CLI/minute.php --create-controllers --file=index.php
```

