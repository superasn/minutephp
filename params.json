{"name":"Minutephp","tagline":"Minute PHP: PHP + AngularJS framework (v.001 alpha)","body":"##MinutePHP: PHP + AngularJS framework (*v.001*)##\r\n\r\n###Framework's USP:###\r\n\r\n- Built-in support for AngularJS\r\n- Router can automatically inject `Model` objects into controller (which can be accessed via AngularJS too)\r\n- CRUD operations can be done with one single line of code in both PHP and AngularJS\r\n\r\n###Project status###\r\nIt's highly experimental code! I just want to share the concept (and code) to see **if anyone interested in collaborating** :)\r\n\r\n###**Demo: Facebook like newsfeed** \r\n\r\n**Demo:** Create a facebook like newsfeed in 2 minutes (using minimum code).\r\n\r\n**Database setup:** Our MySQL database contains a `user` table (`PK: user_id`), `posts` table (`PK: post_id`) and `comments` table (`PK: comment_id`). \r\n\r\nThe `posts` table references the `users` table (since the users make posts) and `comments` table references both `users` and `posts` table (because comments are made on posts by users).\r\n\r\n**Understanding the _new_ Router syntax:**\r\n\r\n```php \r\n$r->get($url, $controller, $acl, â€¦$models)\r\n```\r\n\r\nThe first three arguments are pretty standard:\r\n\r\n1. *$url:* URL *regex* to match address bar. Can contain placeholders (or regex). Placeholder format is \":name\"\r\n  -1. Examples:\r\n     1. /newsfeed/:user\\_id/\r\n     2. /newsfeed/:user\\_id(/:page)? *[here page parameter is optional]*\r\n\r\n2. *$controller:* format is similar to Laravel like \"Filename@function\"\r\n  - Examples:\r\n     1. Backend/Newsfeed@index *[This will invoke the `index` function in `Backend/Newsfeed` class]*\r\n\r\n3. *$acl:* can be \"true\" for logged in otherwise false. \r\n\t- Also supports strings like 'admin', 'power', 'business', 'trial', 'etc' (as defined in config file)\r\n\t\r\n4. **...$model objects: This is the unique part.**\r\n  1. What are model objects?\r\n     1. Models are basically PHP objects that support CRUD operations (in both PHP and AngularJS). Something similar to an ORM but not that (as explained later).\r\n     2. The model classes are *automatically* generated by a script. So for our sample database MinutePHP has generated 5 PHP Model classes called *Users, Posts, Comments, PostsLikes and CommentsLikes*\r\n     3. You can specify the Read, Update, Insert, and Delete permission for each model as \"same\\_user\", \"any\\_user\", \"all\", \"none\", \"admin\", etc (more later).\r\n\r\n5. **The Router automatically injects these Model objects when invoking the Controller**\r\n\r\n**Here is some sample code:**\r\n\r\n**File: `index.php`**\r\n```php\r\n//$r is instance of Router\r\n//Sample matching routes are /newsfeed/1, /newsfeed/2, .. (last part => :user_id)\r\n$r->get('/newsfeed/:user_id', 'Backend/Newsfeed@index', true, 'posts[user_id][]', 'users[posts.user_id] as poster')\r\n```\r\nExplanation of the *last two parameters*:\r\n   \r\n1. ***posts[user_id][]*** - will find all rows in `posts` table with `user_id` = `:user_id` (the placeholder in URL). What this means to you is:\r\n   1.  It will then create `$posts` object (instance of Posts model) with an array of matching rows loaded from our `posts` table where `user_id=1` (if URL is */newsfeed/1*).\r\n   2.  It will pass the `$posts` object when invoking the controller (shown below). \r\n   3. It will **create an AngularJS object** for `$posts`, **accessible as `$scope.posts` inside the view**.\r\n   4. The **[ ]** at end is to specify we want *all* matching results (i.e. an array).\r\n   5. By default all models have a read permission of *same\\_user*, so /newsfeed/2 will return *permission denied error* (if the logged in user's `user_id` is **1** and you try to access /newsfeed/**2**).\r\n   \r\n\t- Example: /newsfeed/**1** will create a `$posts` object and fill it with rows where user_id=**1**.\r\n\t\r\n2.  ***users[posts.user_id] as poster*** - this will create a join on `posts` and `users` table using `user_id`. As a result you will have:\r\n   1. A `$poster` object (instance of User model) in your controller. \r\n   2. A reference to the `poster` inside each row of `$posts` object.\r\n   3. If it is getting confusing, think of it like an SQL query:\r\n```SELECT * FROM posts as A, users as b where user_id = :user_id and b.user_id = a.user_id```\r\n   4. It will also **create an AngularJS object** for you that you can **access as `$scope.posts[0].poster`, `$scope.posts[1].poster.firstName`**, etc in your view.\r\n  5. Note that **there is no [] at the end** this time. It means that we want to load just our **first matching row** (returns single object not array. In JSON speak, it returns `{}` and not `[{}, {}, ...]`)\r\n\r\n**Controller:** `Backend/Newsfeed class`\r\n```php\r\n//This is the Controller class. It is invoked by the Router when a person accesses /newsfeed/1, /newsfeed/2, etc in browser. \r\n\r\npublic function index($posts, $poster) {\r\n\t//$posts and $poster are automatically filled for us\r\n\r\n    //Render Backend/Newsfeed view located in Views folder \r\n    //Magically create an AngularJS object for $posts\r\n\r\n\tView::make('Backend/Newsfeed', $posts); \r\n}\r\n```\r\n**View:** `Views/Backend/Newsfeed.html`\r\n```html\r\n<div class=\"container\">\r\n\tHello!\r\n\t\r\n\t<ng-form>Add new post: <input type=\"text\" ng-model=\"newtitle\" /><button ng-click=\"createPost();\">Create post</button></ng-form>\r\n\t\t\r\n\t<h3>Existing posts</h3>\r\n\r\n\t<!-- Remember $scope.posts is now an AngularJS object! -->\r\n\t<div ng-repeat=\"post in posts\">\r\n\t\t<h3>{{post.title}}</h3> by post.poster.first\r\n\t\t\r\n\t\t<ng-form><input type=\"text\" ng-model=\"post.title\" placeholder=\"title\" />\r\n\t\t   <button ng-disabled=\"post.$dirty\" ng-click=\"updatePost(post);\">Update post</button><ng-form>\r\n\t</div>\r\n</div>\r\n\r\n<script>\r\nfunction extend($scope) {\r\n\t$scope.createPost = function() {\r\n\t    //will create a new post and with the user's title\r\n\t\tvar post = $scope.posts.create().set('title', $scope.newtitle).save();\r\n\t\tconsole.log(\"post: \", post); //will have post_id, etc\r\n\t}\r\n\t\t\r\n\t$scope.updatePost = function(post) {\r\n\t\tpost.save();\r\n\t}\r\n}\r\n</script>\r\n```\r\n\r\n###So are you with me so far? :)###\r\n\r\nAs you can see above, the View class automatically converted our $posts Model into an AngularJS object and added it to our current `$scope` as `$scope.posts`\r\n\r\n`$scope.posts` is an _array of objects_ on which you can iterate with ng-repeat.\r\n\r\n`$scope.posts` is an array but it has a few functions of its own like `.create()`, `loadNextPage()`, etc. \r\n\r\nEach item in `$scope.posts` array is an object of `Record` type (let's call it a `PostItem` in this case) with functions like `set()`, `save()`, etc.\r\n\r\n**But here is the most interesting part!**\r\n\r\nDo you remember about our `users[posts.user_id] as poster` in the router? \r\n\r\nWhat this means to you is that we first created a `$posts` array. Then we created `$poster` object (instance of Users Model) and joined it with the users table by matching the `user_id`.\r\n\r\nSo what this also means to you is that each item inside `$scope.posts` there is a reference to it's `poster` object as well.\r\n\r\nSo `{{$posts[0].poster.firstName}}` will print the first name of the poster in AngularJS.\r\n\r\n>Too hard to comprehend? I hope not! :) But I'll give you another example..\r\n\r\nAlso let's add two more tables called `posts_likes` and `comments_likes`.  \r\n\t- `posts_likes` contains two fields called `user_id` and `post_id` to keep track of which `user` liked which `post`. \r\n\t- `comments_likes` similary contains two fields called `user_id` and `comment_id` to keep track of which `user` liked which `comment`. \r\n\r\nOk, now take a look at this route.. you'll probably go *whaaaaa*, but the concept behind it is simple and once you get it, things will begin to look very easy! :)\r\n\r\n```php\r\n$r->get('/newsfeed/:user_id', 'Backend/Newsfeed@index', false,\r\n\r\n    'posts[user_id][2] order by post_id asc', 'users[posts.user_id] as poster',\r\n\r\n    'postsLikes[posts.post_id][] as plikes', 'users[plikes.user_id] as pliker',\r\n\r\n    'comments[posts.post_id][] order by comment_id desc', 'users[comments.user_id] as commenter',\r\n\r\n    'commentsLikes[comments.comment_id][] as clikes', 'users[clikes.user_id] as cliker'\r\n);\r\n```\r\n\r\nNow let's pull every single parameters apart to make things clear:\r\n\r\n1. `posts[user_id][2] order by post_id asc` Same as last example, only difference is\r\n   1. We load only the first two records only, hence the [2] instead just [] at the end. \r\n   2. To load more records we can call `$scope.posts.loadNextPage()` inside AngularJS.\r\n   3. You can also use `posts[user_id][1,5]` syntax.\r\n\t   - Here the first digit is page number, second digit is number of results. \r\n\t   - So this will load the second page (page starts at 0) with 5 results, i.e. rows: 5 ~ 10.\r\n2.  `users[posts.user_id] as poster` Same as last time. We want to load the poster of each post by creating a join on posts.user_id on the users table. Remember that since we don't have a trailing [] at the end, it tells MinutePHP we want the first matching object (not the whole array of matching results).\r\n3. `postsLikes[posts.post_id][] as plikes` Create a `$postsLikes` object by creating a join on `posts`  and `post_likes` table using `post_id`.\r\n4. `users[plikes.user_id] as pliker` We want to know the name of user who liked the post. So we create a `$pliker` object creating a join on `users` and `postsLikes` (alias plikes) table using `user_id`.\r\n5. `comments[posts.post_id][] order by comment_id desc` Since each posts can have comments inside it, we create a `$comments` object joining `posts` and `comments` using `post_id`.\r\n   6. Since we wish to load the comments in the reverse order in which they were posted, we add an order by clause: `order by comment_id desc` (same as SQL).\r\n6. `users[comments.user_id] as commenter` We also want the name of the user who made the comment, so we create a new `$commenter` object joining the `comments` and `users` table using `user_id`.\r\n7. `commentsLikes[comments.comment_id][] as clikes` This is pretty much same as postLikes, except we're using it for commentsLikes.\r\n\r\n\t-*Note:* that some Models end with `[]` while other don't. In case you've forgotten that is because some times we want the whole array of objects, as in case of $posts, $comments, etc. But other times we just want the first object, as in the user who made the post, or user who made the comment, etc.\r\n\r\nWhen we render our view all these objects will be converted to AngularJS objects. So broadly speaking our code will look something like this:\r\n\r\n```html\r\n<div ng-repeat=\"post in posts\">\r\n\t{{post.title}} by {{post.poster.first}}\r\n\r\n\t<div ng-repeat=\"comment in post.comments\">\r\n\t\t{{comment.title}} by {{comment.commenter.first}}\t\t\r\n\t</div>\r\n\r\n\t<input type=\"text\" ng-model=\"userinput\" />\r\n\t<button ng-click=\"createItem(post.comments)\">Add comment</button>\r\n</div>\r\n\r\n<input type=\"text\" ng-model=\"userinput\" />\r\n<button ng-click=\"createItem(posts)\">Add new post</button>\r\n\r\n<button ng-click=\"posts.loadNextPage();\" ng-show=\"posts.$more\">Next page ></button>\r\n```\r\n\r\nWhat it does?\r\n- Show the first two posts, print their titles along with the name of the user who made the post.\r\n- Inside each post will be all the comments with the name of the user who made it!\r\n- A logged in user can add a new post to this page.\r\n- A logged in user can add a new comment under each post.\r\n- The Next page button will add two more posts.\r\n\r\nSimilar to example #1, if you want the user to create a new post or comment, all you have to do is this:\r\n\r\n```html\r\n<script>\r\nfunction extend($scope) {\r\n\t$scope.createItem = function(item) {\r\n\t    //will create a new post or comment\r\n\t\titem.create().set('title', $scope.userinput).save();\r\n\t}\r\n}\r\n</script>\r\n```\r\n\r\nNow the last part. How to add comment and post likes? Well, it's easy.\r\n\r\nWe already have created a `$plikes` object for each post. Let's say we want to show the number of people who like the post:\r\n\r\n```html\r\n<div ng-repeat=\"post in posts\">\r\n\t{{post.title}} by {{post.poster.first}}\r\n\r\n\t<span>{{post.plikes.count-1}} like this post!</span>\r\n\t<ng-switch on=\"didILike(post.plikes)\">\r\n\t\t<a ng-show-when=\"false\" ng-click=\"likePost(post)\">like this post!</a>\r\n\t\t<a ng-show-default ng-click=\"unLikePost(didILike(post.plikes))\">Unlike!</a>\r\n\t</ng-switch>\r\n</div>\r\n\r\n<script>\r\nfunction extend($scope) {\r\n\t$scope.likePost = function(post) {\r\n\t    post.plikes.create().save();\r\n\t}\r\n\t\r\n\t$scope.unLikePost = function(plike) {\r\n\t    plike.remove();\r\n\t}\r\n\r\n\t$scope.didILike = function(arr) {\r\n\t\t//using underscore.js, return object where user_id == 1;\r\n\t\treturn _.findWhere(arr, { user_id: 1}) || false;\r\n\t}\r\n}\r\n</script>\t\r\n```\r\n\r\nTo quickly explain the above code:\r\n\r\nWhen a user likes a post we simply have to add the user\\_id, and post\\_id to our `PostsLikes` table. So in our case we just call `plikes.create()` and save it.\r\n\r\nThe `didILike` function is basically returns the first matching object inside the `$scope.posts.plikes` array where the object has `user_id` = 1 (we assume the logged in user's user_id = 1 for this demo).\r\n\r\nTo unlike a post, we simply just pass this Record (or the matching item inside the `$scope.posts.plikes` array) and call the remove function on it, thus deleting the record and removing the like.\r\n\r\nTo keep things simple I have not covered the creation, updating and removal of objects so far. By default all models are created with the following permissions:\r\n\t- **Read** permission: `same_user` (i.e. the person who created the record can only read it.. or basically the user_id has to match)\r\n\t- **Update** permission: `same_user` (i.e. the person who created the record can only update it..)\r\n\t- **Insert** permission: `none` (nobody can insert anything by default)\r\n\t- **Delete** permission: `none` (nobody can delete anything by default)\r\n\r\nSo to let users insert or delete stuff we have to setup routes to make it possible. The only code you have to add here is change the Model permissions to allow this to happen.\r\n\r\nSo take this sample:\r\n\r\n**File: `index.php`**\r\n\r\n```php\r\n//$r->get('/newsfeed/:user_id', 'Backend/Newsfeed@index', false, ...\r\n  $r->post('/newsfeed/:user_id/posts/update', 'Backend/Newsfeed@updatePosts', false, 'posts[$data]');\r\n```\r\n\r\n**Controller:** `Backend/Newsfeed class`\r\n```php\r\n//This is the Controller class. It is invoked by the Router when a person makes a POST request to /newsfeed/1/posts/update\r\n\r\npublic function updatePosts($posts) {\r\n    if ($posts->getAction() == 'remove') {\r\n        $posts->setDeletePermission('same_user');\r\n        $success = $posts->remove();\r\n    } else {\r\n        $posts->setUpdatePermission('same_user');\r\n        $posts->setInsertPermission('same_user');\r\n        $success = $posts->save();\r\n    }\r\n\r\n    View::getInstance()->make('Backend/Newsfeed', $success);\r\n}\r\n```\r\n\r\nThe advantage of this approach is that your scripts will continue to work even if the user has disabled Javascript on her end. This is important for Signup pages, old mobile devices, etc.\r\n\r\n###Generating Model Classes and Controllers###\r\n\r\nYou don't have to write most of the stuff by hand. The *minute.php* `CLI` script will create both Models and Controllers Classes for you.\r\n\r\n**Examples:**\r\n```php\r\n#To create Model Classes (only support MySQL currently)\r\n$> php Minute/CLI/minute.php --create-models --db=fb --host=localhost --user=root\r\n\r\n#To generate Controller classes (file must be inside `public` directory)\r\n$> php Minute/CLI/minute.php --create-controllers --file=index.php\r\n```\r\n\r\n###So what's next?###\r\n\r\n1. **Controller chaining:** You may ask.. what's that? It's basically a way to create an array of controllers and chain them together like this:\r\n\r\n\t**File: `index.php`**\r\n\t\r\n\t```php\r\n\t$r->get('/billing/paypal', ['Plugins/Paypal@IPN as ipn', 'Billing@process'], false, ...)\r\n\t$r->get('/billing/2co',    ['Plugins/TwoCO@IPN as ipn', 'Billing@process'], false, ...)\r\n\t```\r\n\t\r\n\tThere are a bunch of task that you have to do in every site, so I am thinking that we can write a few plugins, and then chain these to our controllers using an array. So that when the `process` function is invoked in the `Billing` class it is automatically injected with a `$ipn` object that has already processed the payment and contains a simple `$payment` object like `{pass: true, amount:33.33}`\r\n\r\n2. **HybridAuth integration:** I think hybriadauth is the best solution for implementing login and signup. So I will probably use that and create an OAuth provider inside MinutePHP to provide the option to signup by email.\r\n\r\n3.  **An `$scope.posts.on('item_added', ...)` handler:** Right now the only way to check for changes is via the `.$dirty` flag on Records [it automatically resets after `.save()`]. \r\n\r\n\tBut instead I want to add a Global `.on` handler that fires events even when the `$scope.posts` is changed by *anybody*. This can be easily implement using Websockets. \r\n\r\n\tSo take for example, our facebook feed demo, if there was a to hook `$scope.posts.on('item_added', ..)` we can easily create a notification for the user that a new post was created, or somebody liked their post, comment, etc.\r\n\r\n\r\n###What else?###\r\n\r\nIt's just something I'm doing in my spare time. It is by no means perfect or production ready but the sample code works great so far it is working exactly as I expected. \r\n\r\nSorry for not taking a TDD approach. I was having way too much fun with the Router and Models that I kinda skipped that :P But the PHPUnit tests are coming very soon :) Of course some help with that would be greatly appreciated always.\r\n\r\nBy the way, I've tried the facebook feed demo with about 100,000 records and the system seems to run like a breeze. The total lines of code is about 50 which consists of mostly HTML (or AngularJS).\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}